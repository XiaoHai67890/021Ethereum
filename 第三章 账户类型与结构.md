**第三章**

账户类型与结构

本章目标：搞懂EOA与合约账户差异与互动方式。

**正式开始之前先做一些补充知识：**

**CREATE（传统创建）**：合约地址由 *创建者地址 + 创建者的 nonce*
决定，地址不可在部署前精确预测（除非知道 nonce）。公式上是
<span class="mark">keccak256( RLP(\[s</span>

<span class="mark">ender, nonce\]) )</span> 的后 20 字节。

**CREATE2（EIP-1014 引入）**：合约地址由 *创建者地址 + salt +
init_code*（init_code
的哈希）决定，地址在部署前可以被**精确预计算**：<span class="mark">keccak256(0xff
++ deployer ++ salt ++ keccak256(init_code))</span> 的后 20 字节（0xff
是定界前缀）。CREATE2 于 Constantinople（EIP-1014）引入。

**作用差异要点**：CREATE2 的最大价值是**可预测地址（deterministic
deployment）与跨链/跨环境一致性**（相同输入在任意 EVM
链上会生成相同地址），常用于工厂合约、代理/升级模式与“counterfactual
contracts（反事实合约）”。

# EOA（Externally Owned Account）是什么？如何控制？

大家可以把这一节记成一句话：

> EOA =
> 由“私钥”直接控制的钱包账户，能发交易、收资金、调合约，但自己不带代码逻辑。控制私钥的人
> = 控制这个账户的一切。

## EOA 是什么？和合约账户有什么区别？

**1.1 EOA（Externally Owned Account，外部拥有账户）**

- 由**公私钥对**控制，用户（人 / 机构）持有私钥；

- 可以发起交易（转账、调用合约）、持有 ETH 和各种代币；

- 账号本身**没有代码**，不会自动执行任何逻辑。

以太坊里只有两类账户：

**①EOA**：

- 有私钥

- 能“主动发起交易”

- 没有合约代码

**②合约账户（Contract Account）**：

- 无私钥，由部署时的代码“锁死行为”

- 不能主动发起交易，只能“被调用”后按合约逻辑执行

- 有代码和存储（storage）

用一句对比记忆：

> EOA 像“人 + 银行卡”，合约账户像“写死规则的自动售货机”。

## 一个 EOA 在状态里到底长什么样？

在以太坊世界状态里，每个账户（不论是 EOA 还是合约账户）都有固定字段：

- **地址（address）**

  - 从公钥派生，20 字节，以 <span class="mark">0x</span> 开头的 40
    个十六进制字符。

- **nonce（交易计数器）**

  - 对于 EOA：表示**这个账户已经发送过几笔交易**。

  - 一笔交易的 nonce 必须等于当前账户 nonce，打包成功后 nonce+1。

  - 作用：**防止重放攻击 & 保证交易有序** —— 同一个 nonce
    只允许执行一次。

- **balance（余额）**

  - 账户持有的 ETH 数量，以 wei 计（1 ETH = 10¹⁸ wei）。

- **code / storage**

  - 对于 EOA：<span class="mark">code</span>
    为空，没有合约代码；<span class="mark">storage</span> 也为空。

  - 对于合约账户：<span class="mark">code</span> 保存 EVM
    字节码，<span class="mark">storage</span> 保存合约状态。

所以：**EOA 只是一对“钥匙 + 几个数字字段（nonce /
balance）”，本身不带逻辑。**

##  我是怎么“控制”一个 EOA 的？

**3.1 私钥签名：真正的控制权**

从本质上讲：

持有私钥的人，才是这个 EOA 的真正“主人”。

- 每个 EOA 对应一个**私钥 / 公钥对**；

- 发起交易时，用**私钥**对交易数据签名（包含 <span class="mark">from /
  to / value / nonce / gas …</span>）；

- 网络节点通过公钥验证签名，确认：

  - 这个交易确实由这个地址发出；

  - 交易内容未被篡改。

一旦私钥泄露：

- 对方可以任意发起转账、调用合约、清空你的余额；

- 区块链无法“冻结”或“找回”，因为系统只认“谁能签名”。

**3.2 助记词（BIP-39）和派生路径（BIP-44）**

实际钱包里，你很少直接看到“私钥字符串”，而是看到一串**助记词**（12/24
个英文单词）：

- **BIP-39** 定义了“助记词 → 种子 → 一棵 HD 钱包密钥树”的标准：

  - 人类容易记的词 ⇋ 大随机数 ⇋ 一堆私钥 / 地址。

- **BIP-44**
  在此基础上定义了**多币种、多账户、多地址的分层结构**，约定了常见派生路径（如
  <span class="mark">m/44'/60'/0'/0/0</span> 对应以太坊第一个地址）。

所以：

> 那 12/24 个单词 = 一把“万能总钥匙”，能派生出你钱包里所有 EOA
> 地址。这也是为什么安全提示永远在强调：

- 不要截图 / 云盘存助记词；

- 不要在不可信网页 / App 里输入助记词。

**3.3 Nonce：阻止“把你签过的交易拿出来复读”**

Ethereum 官方文档直接说明：

> nonce 是针对每个 EOA 的递增计数器，只允许每个 nonce
> 对应一笔交易，防止攻击者把已经签过的交易反复广播执行。

也就是说：

- 即使别人截获了你**已成功上链**的交易数据；

- 在你账户 nonce 已经前进的情况下，再次广播这笔交易会被直接拒绝；

- 所以不能简单地“复读你签过的数据”来做链上重放。

（跨链 / 分叉场景会有专门的 replay
问题，那属于更进阶的话题，可以在别处展开。）

**3.4 Gas：想让 EOA 动起来，必须给它加油**

EOA 想发交易或调合约，必须支付 **gas 费**，而 gas 费用的是 ETH（或 L2
的原生代币）：

- 账户余额不足以覆盖 <span class="mark">gas_limit × gas_price</span>
  的话，交易会被节点拒绝；

- 这保证任何 EOA 想对链发动“垃圾攻击”，都要付真金白银的成本。

## 实战视角：开发者 & 普通用户要注意什么？

**4.1 对开发者**

- 你在前端看到的钱包地址（MetaMask 等），本质就是一个 EOA；

- dApp 与 EOA 的交互，就是通过
  <span class="mark">eth_sendTransaction</span> /
  <span class="mark">eth_signTypedData</span> 让用户用私钥签名；

- 合约里调用 <span class="mark">msg.sender</span> 时，如果调用方是
  EOA，那就是“真实用户”；如果是合约，则是“合约地址”。

**4.2 对普通用户**

- **控制私钥 / 助记词的人，就是账户真正的主人**；

- 最安全的做法是使用 **硬件钱包** 管理私钥，把助记词线下保存；

- 任何要求你“输入助记词到网页”的项目，99% 当诈骗处理。

**4.3 类比：银行账户**

- **EOA 地址**：像**银行卡号**，别人可以转钱给你；

- **私钥**：像**银行卡 + 密码 +U
  盾**合体，只要别人拿到了，就能把钱全部转走；

- **助记词**：像一张能复刻所有银行卡的“主密码纸”，丢了就等于把所有卡的控制权送人；

- **nonce**：像银行给每笔转账排的流水号，防止同一笔指令被执行两次。

可以背诵的一句话：

> EOA =“由私钥直接控制的以太坊账户”。
> 区块链不认识你是谁，只认你能不能拿出对应的私钥签名。

下面是一个表格，方便大家查看与理解：

| 属 性 | 内 容 |
|:-----------------:|:----------------------------------------------------|
| **私钥与公钥** | EOA 是由一个密码学 key pair（私钥 + 公钥）控制的。私钥用于签名，公钥经过哈希等计算生成地址。 |
| **地址** | 公钥派生出地址。以太坊地址通常是20字节 /40个十六进制字符 + "0x" 前缀。 |
| **Nonce（交易计数器）** | 跟踪这个EOA曾经发送过多少交易，用来防止重放攻击。 |
| **Balance（余额）** | EOA 可以持有ETH或代币余额。区块链状态里记录这个账户在世界状态树（World State）中的余额。 |
| **Code / Storage** | 对于 EOA，code部分是空的（没有智能合约代码）。也没有“storage root”（存储状态），这些是合约账户（Contract Account）才有的。 |

# 合约账户是什么？它是如何被创建的？

一句话把这节定调：

> 合约账户 = “带代码的账户”，不靠私钥，而是靠部署在链上的 EVM
> 字节码决定它能做什么；
>
> 它是通过 **“创建合约交易 + 部署字节码 + CREATE / CREATE2 地址规则”**
> 被创建出来的。

## 合约账户是什么？

在以太坊里有两种账户：

**1.1 EOA（Externally Owned Account，外部拥有账户）**

- 有私钥，用户通过钱包控制；

- 不能存代码，只能签名、发交易。

**1.2 合约账户（Contract Account / Smart Contract Account）**

- **没有私钥**，它的行为完全由\*\*账户里的代码（EVM bytecode）\*\*决定；

- 有自己的**地址和 ETH 余额**，也可以持有 ERC-20 / NFT；

- 有 **code**（合约逻辑）和
  **storage**（状态存储），可以读写状态、转账、调用其他合约；

- **不能主动发起“外部交易”**，只能在被 EOA
  或其他合约调用时执行（内部消息调用）。

从世界状态的角度，合约账户和 EOA 一样，状态里都有 4 个字段：

- <span class="mark">nonce</span>：

  - 对 EOA：已发送交易数量；

  - 对合约账户：**曾经用 CREATE / CREATE2 创建过多少个合约**。

- <span class="mark">balance</span>：账户持有的 ETH 数量。

- <span class="mark">storageRoot</span>：该合约存储 trie
  的根哈希（合约状态的入口）。

- <span class="mark">codeHash</span>：EVM
  字节码的哈希，用于在底层存储中定位合约代码。

## 合约账户是如何被创建的？

大多数情况下，一个合约账户的诞生会经历下面几步：

**1. 编写并编译合约**

- 开发者使用 **Solidity / Vyper 等高级语言**编写智能合约；

- 编译器把源码编译成 **EVM 字节码**：

  - **init code（初始化/构造代码）**：部署时执行，类似“构造函数”；

  - **runtime
    code（运行时代码）**：部署完成后真正留在链上、对外执行的部分。

**2. EOA 或合约发起“创建合约交易”**

- 一笔**创建合约的交易**特点是：

  - <span class="mark">to</span> 字段为空（null 地址）；

  - <span class="mark">data</span> 字段写入 **init code（+
    构造函数参数编码）**；

- 这笔交易一定需要支付 gas：代码存链 + 执行构造逻辑都要花费 gas。

这个“发起人”可以是：

- 一个 **EOA**（你在 Remix/Hardhat 里部署合约时就是这样）；

- 一个已经在链上的**合约（工厂合约 factory）**，通过 EVM 的
  <span class="mark">CREATE / CREATE2</span> 指令再部署一个新合约。

**3. EVM 执行 init code，写入 code & 初始 storage**

当矿工/验证者在 EVM 中执行这笔“创建合约交易”时，会做几件事：

> ①看到 <span class="mark">to == null</span>，识别这是**创建合约交易**；
>
> ②运行 <span class="mark">data</span> 里的 **init code**；
>
> ③init code 的最后会 <span class="mark">RETURN</span>
> 一段字节码——这就是 **runtime code**；
>
> ④EVM 把这段返回值作为**新合约账户的 code**，写入世界状态；
>
> ⑤同时，根据构造函数执行结果初始化 storage（状态变量）；
>
> ⑥若 gas 不足，或 init code
> 执行失败，整个创建会回退，**不会生成合约账户**。

最终，新合约账户出现在状态树中，拥有：

- 一个新地址；

- 一段固定的 runtime bytecode；

- 初始存储状态（所有状态变量的初始值）。

## 合约地址是如何计算出来的？

合约地址**不是随机的**，而是**确定性可计算**的，这一点对“预先计算地址、钱包工厂、Create2
部署”等很重要。

**3.1 普通 CREATE：<span class="mark">sender + nonce</span> 决定地址**

当使用 **CREATE**（最常见方式）部署合约时，新合约地址由：

> address = last_20_bytes( keccak256( rlp(\[sender, nonce\]) ) )

其中：

- <span class="mark">sender</span>：发起合约创建的账户地址（EOA
  或合约）；

- <span class="mark">nonce</span>：这个账户**在创建时的交易/合约创建计数**。

换句话说：**同一个 deployer 地址 + 同一个 nonce → 合约地址唯一确定**。

**3.2 CREATE2：<span class="mark">0xff + deployer + salt +
keccak(init_code)</span>**

EIP-1014 引入的 **CREATE2** 允许“提前预测合约地址”，计算公式为：

- <span class="mark">deployer</span>：执行 CREATE2 的合约地址；

- <span class="mark">salt</span>：32 字节的盐，由开发者自定义；

- <span class="mark">init_code</span>：完整的部署字节码（包含构造逻辑）。

特点：

- **同样的 deployer + salt + init_code → 永远得到同一个地址**；

- 和 nonce 无关，因此可以跨链用相同的组合在多条 EVM
  链上得到同一地址（只要规则一致）。

这让很多“钱包工厂”、“合约钱包账户抽象”、“预留地址”玩法成为可能。

## 合约账户的能力与限制

**4.1 能力**

- 持有 ETH / Token；

- 内部存 code & storage，可以实现任意复杂逻辑：DEX、NFT、DAO 等；

- 可以在执行中给别的地址转账、调用其他合约、甚至使用 CREATE / CREATE2
  再创建新合约。

**4.2 限制**

- **没有私钥**，因此不能像 EOA 一样“签名并主动发起外部交易”；

  - 所有行为都必须由外部交易触发（EOA
    调用它，或另一个合约在执行中调用它）。

- 部署合约必须付较高 gas：

  - 因为需要把代码**永久存储在链上**，这在 EVM 里是昂贵操作。

- 部署后的代码一般不可变（除非自己写了代理 / 升级模式），只有 storage
  可以随调用改变。

**4.3 类比：自动售货机 vs 银行卡**

类比把 EOA 和合约账户串起来：

- **EOA：银行卡账号**

  - 你（持私钥的人）决定什么时候转账，

  - 银行系统只是帮你记账。

- **合约账户：上链的自动售货机 / 自动柜台**

  - 你事先写好规则，把机器放在那里（部署合约）；

  - 任何人往里面投钱/按按钮（发交易调用合约），

  - 售货机会按照写死的程序自动执行：

    - 吐货、退钱、转账、更新库存（storage）。

售货机**没有“密码”可以让你随意改规则**，你只能在设计规则的时候把逻辑想好；这就是智慧合约的特性：**一旦部署，就由代码“接管账户”，而不是由人手动控制。**

# 为什么以太坊地址都是以“0x”开头？

先来一句话先掐死这题：

以太坊地址本质是一串 20 字节（160
bit）的二进制数据，写成字符串时通常用十六进制展示，于是按照编程界传统加了个前缀
0x，用来标明：“注意，这是 hex 不是普通数字。”

## 地址本体是 160 bit，只是“长得像 0x……”

在协议层，以太坊地址**只是一个 160 bit 的值**：

- Yellow Paper 和官方教程都把地址定义为 160 位（2¹⁶⁰）空间中的一个值。

- 展示给人看的时候，一般用十六进制字符串表示：

  - 20 字节 = 160 bit；

  - 每个 16 进制字符表示 4 bit；

  - 所以刚好是 **40 个 hex 字符**。

于是就有了我们熟悉的格式：

0x + 40 个十六进制字符（0–9, a–f） → 总长度 42。

## 为什么偏偏是 <span class="mark">0x</span>？

这是**编程界的老传统**：

- 在 C / C++ / JavaScript 这类语言里，<span class="mark">0x</span>
  一直被用来表示“**后面这串是十六进制**”：如
  <span class="mark">0xff</span>、<span class="mark">0xdeadbeef</span>。

- 以太坊沿用了这一习惯：

  - Yellow Paper 里直接写“地址用十六进制表示，**通常会加上 0x
    前缀来显式标记**”。

- 钱包、区块浏览器、文档统一写成
  <span class="mark">0x...</span>，久而久之变成**行业约定俗成的格式**。

这有几个好处：

**①一眼能看出是地址 / hex**，而不是某个普通 ID 或十进制数字；

②在文档、日志、代码里查找、正则匹配都更方便；

③避免和其他格式（比如 Base58、十进制）混淆。

## <span class="mark">0x</span> 算地址的一部分吗？必须写吗？

严格讲：

- **链上的“地址值”本身不包含 <span class="mark">0x</span>**，它只是一串
  160 bit 的二进制；

- <span class="mark">0x</span> 是**文本表达**时的前缀 ——
  类似“标点/标签”，不是数据的一部分。

在很多库/工具里你会看到类似的要求：

- 字符串地址格式：<span class="mark">(0x)?\[0-9a-fA-F\]{40}</span> ——
  也就是说，**带不带 <span class="mark">0x</span>
  都能识别**，只是推荐带上。

所以：

- 钱包、浏览器 UI：几乎都会显示成 <span class="mark">0x...</span>；

- 某些 API / 数据库字段：允许不带 <span class="mark">0x</span> 的纯 40
  位 hex（自己再加也行）。

## 和 checksum / 大小写有什么关系？

顺带解释 EIP-55：

- EIP-55 定义了“**混合大小写的 checksum
  地址**”，用大小写模式来做校验，减少手动输入地址时的错误。

- checksum 地址仍然是：<span class="mark">0x</span> + 40 个 hex
  字符，只是其中部分字母会变成大写。

- 区块链在执行层面对大小写**不敏感**；checksum 只是“客户端 /
  UI”层面的安全增强。

## 类比方便理解

一个类比：

> 可以把 0x 想成“货币符号”：

- <span class="mark">$100</span> 里的 <span class="mark">$</span>
  告诉你：这是美元金额；

- <span class="mark">0x1234...</span> 里的 <span class="mark">0x</span>
  告诉你：这是一个**十六进制地址**。

> 真正的钱是数字本身，$ 只是前面的标记；
>
> 真正地址是那 20 字节/40 个 hex 字符，0x 只是告诉你“这是一串 hex
> 地址”。

一句话（可以直接背诵）：

> 以太坊地址加 0x，不是因为协议强制，而是为了“让人和程序一眼识别：这是
> 16 进制地址”。

# EOA和合约账户的控制方式有何区别？

可以把它理解成：

> EOA =“由私钥直接控制的人类钱包”；
>
> 合约账户 =“由代码控制的自动售货机”。

<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 38%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><strong>区别维度</strong></th>
<th style="text-align: center;"><p><strong>EOA</strong></p>
<p><strong>(Externally Owned Account，外部拥有账户)</strong></p></th>
<th style="text-align: center;"><p><strong>合约账户</strong></p>
<p><strong>（Contract Account / Smart Contract
Account）</strong></p></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">控制主体</td>
<td style="text-align: left;"><strong>私钥 / 助记词</strong>
持有者控制账户；谁拿到私钥，谁就能发交易。</td>
<td
style="text-align: left;">由<strong>部署在账户里的代码</strong>控制行为；没有私钥，规则写死在智能合约逻辑中。</td>
</tr>
<tr>
<td style="text-align: center;">行为触发方式</td>
<td
style="text-align: left;">可以<strong>主动发起交易</strong>：转账、调用合约，只要签名
+ 有足够 gas。</td>
<td
style="text-align: left;"><strong>不能主动发起外部交易</strong>；只能在被
EOA 或其他合约调用时执行（内部 message call）。</td>
</tr>
<tr>
<td style="text-align: center;">是否存在私钥</td>
<td style="text-align: left;">有私钥 + 公钥，对应地址；“控制权 =
私钥所有权”。</td>
<td
style="text-align: left;"><strong>没有私钥</strong>；任何“权限控制”都由合约内部的
<mark>require(msg.sender == …)</mark>、角色管理、多签等代码实现。</td>
</tr>
<tr>
<td style="text-align: center;"><p>功能</p>
<p>灵活性</p></td>
<td style="text-align: left;">自身功能很简单：签名 →
发交易；要实现复杂逻辑一般需要配合合约。</td>
<td
style="text-align: left;">逻辑高度可编程：可实现多签、时间锁、访问控制、代币发行、治理、金库、机器人逻辑等。</td>
</tr>
<tr>
<td style="text-align: center;"><p>风险与</p>
<p>信任点</p></td>
<td
style="text-align: left;">主要风险是<strong>私钥管理</strong>：丢失=永久失去控制；泄露=资产被直接转走。</td>
<td style="text-align: left;">主要风险在于<strong>代码漏洞 / 逻辑错误 /
权限设计不当</strong>；一旦部署，代码通常不可改，只能通过预先设计的升级机制（proxy等）调整。</td>
</tr>
<tr>
<td style="text-align: center;">创建成本与方式</td>
<td style="text-align: left;">生成 EOA 只是本地生成一对 key
pair，<strong>不需要上链、不花 gas</strong>。</td>
<td style="text-align: left;">部署合约账户必须发一笔“创建合约交易”，把
bytecode 写入链上，<strong>需要支付不少 gas</strong>。</td>
</tr>
<tr>
<td style="text-align: center;">行为/权限的可修改性</td>
<td style="text-align: left;">EOA
自身没有代码，行为模式基本固定（签名+发交易）；想要更复杂控制（多签等）通常借助合约钱包。</td>
<td
style="text-align: left;">合约代码一旦部署一般<strong>不可变</strong>；只能通过合约内预留的升级逻辑、代理模式或
<mark>selfdestruct</mark> 等机制间接“修改”行为；storage
状态可以通过函数调用改变。</td>
</tr>
</tbody>
</table>

这里提到了多签和时间锁，来做个补充介绍。

## 多签（Multisig）详解

**定义（英文全称）**

**Multisignature (Multisig
Wallet)**：一种需要多个签名/批准才能执行交易的账户或智能合约钱包。

**工作原理（核心）**

常见模型为 **M-of-N**：比如 2-of-3 表示 3 个 owner 中至少 2
个签名同意才执行。

技术实现通常是部署一个智能合约（wallet
contract）保存资产，并通过合约内函数管理提案、签名集合与执行（Gnosis
Safe 是主流实现）。用户发起“交易提案”，其他 owners
在界面或离线签名后，达到阈值合约执行交易。

**现实例子**

**Gnosis Safe**（前称 Gnosis Multisig）：被广泛用于
DAO、多方托管、项目国库管理。界面友好、可安装模块。

**优点**

把单点密钥泄露风险降到最低（需要同时攻破多把钥匙才能拿走资产）。

适合团队决策流程（例如多人审批支出）。

## 时间锁（Timelock）详解

定义（英文全称）

**Timelock / Time lock (Timelock Controller / Timelock
Contract)**：在智能合约或治理流程中，对某些敏感操作设置
**预定延时（delay）**，在延时到期后操作才可被执行。常见实现：OpenZeppelin
的 TimelockController。

**工作原理（核心）**

管理角色（proposer、executor、admin）提交一个“计划好的”交易到 timelock
合约。提交后必须经过设定的 delay 时间窗口（例如 2 天、7 天、或 48
小时）才能由 executor
发起实际执行；在这段时间，社区/用户可以审查、挑战或撤出资金。

现实例子与用途

**治理（DAO/Protocol
upgrades）**：在链上治理通过后，升级合约或变更参数先放入
timelock，给用户时间进行反应（例如退出、投票）——这是多数 DeFi
项目的做法（Compound、Aave 等均采用 timelock
或类似流程）。（相关文章与教程说明 timelock 的治理作用）。

**资金解锁 /
归属期（vesting）**：用于代币团队/投资人的归属锁定期（vesting）与分期释放。

优点

**透明**：任何人可看到将会发生的操作与执行时间。

**缓冲/缓解风险**：给用户/审计方时间发现恶意升级或漏洞并采取行动（撤资、告警、软分叉/其他对策）。

## 限制与风险

**延迟影响响应速度**：在紧急修复漏洞时，延迟会成为负担——通常会配合“guardian
/ emergency pause” 机制处理。

**依赖 timelock 本身的安全性**：timelock 合约要托管重要权限（ownership /
admin），必须高度审计。若 timelock
被攻破，攻击者能在延时后执行恶意操作。

控制方式的技术机制差异

**私钥签名VS合约逻辑判断**EOA
控制事务的权限是通过数字签名（在交易里签名字段）来实现的。合约账户的“权限”则体现在合约内部函数中，包括
msg.sender, require(...) 等条件判断。合约可以检查是谁在调用、value
是否足够、状态是否允许等。

## 代码存在性（Code）

可以通过 RPC 方法 eth_getCode(address)
判断某地址是否为合约账户：如果返回的代码非空，就说明有智能合约存在，是合约账户；否则为
EOA。

**Nonce 行为**EOA 的每次交易发送会使其 nonce
增加，用来防止重放攻击；合约账户不是通过 nonce
来发起交易，对其行为的控制在于它被谁以何种“transaction / message
call”触发。

## 类比帮助理解

把 EOA 和合约账户之间控制方式的区别，比作现实中“人 vs 机器自动柜员机
/自动售货机”的区别：

**EOA（人）**：你有钥匙（私钥）。你想转钱、打电话、去买东西，你可以自主行动。你能判断什么时候行动，怎样行动。

**合约账户（机器 /自动售货机
/柜员机）**：机器本身有程序规则（代码），当你把钱投入
/按下按钮（外部触发）后，它按照预设规则（程序）做动作。你没有钥匙控制机器本身后台逻辑，只能通过前面接口触发它。

# 哪种账户可以主动发起交易？为什么？

能够主动发起交易的账户只有EOA（外部拥有账户，Externally Owned
Account），这是因为：

EOA由私钥控制，用户通过签名发送交易请求并广播至网络，因此它们能够主动发起交易——包括转账、调用智能合约等行为。根据以太坊当前协议设计，**每一笔链上
transaction 的起点，依然必须是一个由私钥签名的账户**，也就是 EOA。

合约账户（Contract
Account）由智能合约代码控制，没有私钥，无法主动创建交易。它们只能在收到EOA发出的调用时被动执行逻辑，因此不能主动发起交易——这一点在今天依然成立：**合约可以执行
<span class="mark">call</span> / <span class="mark">delegatecall</span>
/ <span class="mark">create</span>
等内部消息，但不能凭空生成新的顶层交易（top-level transaction）。**

## 图表：EOA vs 合约账户的“主动发起交易”能力

<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 42%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><strong>机 制</strong></th>
<th style="text-align: center;"><strong>为什么 EOA
能发起交易</strong></th>
<th
style="text-align: center;"><p><strong>为什么合约账户不能主动发起</strong></p>
<p><strong>（在标准场景下）</strong></p></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>私钥控制</strong></td>
<td style="text-align: left;">EOA
拥有私钥，可以签名交易。签名是发起交易不可或缺的一步。</td>
<td
style="text-align: left;">合约账户本身没有私钥，因此不能进行签名，也就无法“发起”交易。</td>
</tr>
<tr>
<td style="text-align: center;"><strong>发起者角色(transaction
origin)</strong></td>
<td style="text-align: left;">在以太坊中，transaction 一般由 EOA
发起，并提交给网络（mem-pool），然后被矿工／Validator 包含进区块。</td>
<td
style="text-align: left;">合约账户只能在收到一个交易或者被调用时响应；它不会自己发起一个新的
transaction。</td>
</tr>
<tr>
<td style="text-align: center;"><p><strong>gas /手续费</strong></p>
<p><strong>付费机制</strong></p></td>
<td style="text-align: left;">发起交易（EOA 发起）时该 EOA 要付 gas（以
ETH 支付）。所以 EOA 必须持有 ETH。</td>
<td style="text-align: left;">合约账户没有私钥，也不能自主提供
gas；通常是别的账户或调用方付 gas。当合约代码运行时，gas
是由触发它的那笔交易中提供。</td>
</tr>
<tr>
<td style="text-align: center;"><p><strong>以太坊设计</strong></p>
<p><strong>&amp;协议规则</strong></p></td>
<td style="text-align: left;">Ethereum
的交易模型设计中要求交易签名必须来自一个私钥，这是 EOA
的功能。协议里没有“合约账户自行生成交易”的机制（除非在某些新的抽象化提案
/标准中有所拓展）。</td>
<td style="text-align: left;">合约账户只能响应 transaction
或调用；为了安全、可预测性、不可滥用，协议不允许合约自己主动在没有外部触发的情况下发起交易。</td>
</tr>
</tbody>
</table>

**  **

## 也有一些特别的情况：

**ERC-4337 账户抽象** 和 **EIP-7702 / Pectra 升级**。

**2.1 ERC-4337：合约钱包“像在发交易”，但真正广播的还是 EOA**

正如下面的话：

Account Abstraction（账户抽象, 如 ERC-4337）：让智能合约类的账户（Smart
Contract Accounts）具备类似 EOA
的一些操作能力，比如可以让用户通过合约钱包／捆绑操作提交一个
UserOperation，而这个操作由捆绑器（bundler）提交到网络。虽然合约账户在形式上可能“发起”操作，但底层仍有
EOA 或者特殊机制参与签名与 gas 支付。

补充更新：

- **ERC-4337 已在 2023 年 3 月部署到以太坊主网**，无需修改共识层，通过
  EntryPoint 合约 + UserOperation 的方式在“应用层”实现账户抽象。

- 从 2023–2024 年，ERC-4337 智能账户在以太坊和各大 L2
  上快速增长，统计显示到 2024 年底累计已部署**上千万级别的 smart
  accounts**，2024 年单年新增接近 2000 万个 ERC-4337 智能账户。

- **关键点没变**：UserOperation 不是链上的“原生交易类型”，而是提交给
  **Bundler** 的“意图对象”；Bundler 最终还是用自己的 **EOA
  签名并发送一笔普通交易** 调用 EntryPoint，把多条 UserOperation
  打包执行。

所以：从协议视角看，真正写进区块的仍然是一笔由 EOA
发起和签名的交易；合约钱包只是让“谁来验证签名、谁替你付
gas、如何组织多步调用”变得可编程。

**2.2 “自触发”机制：本质还是外部服务在帮合约按按钮**

有些合约设计了“自触发”机制（例如定时器 or oracle
trigger），但这些机制仍须由外部资源或者 EOA
或链外服务触发。合约本身不会凭空启动新交易。

现在常见的是：

- 各种 **automation / keeper 服务**（如 Gelato、Chainlink Automation
  等）在链下定时检查条件，一旦满足，就用自己的 EOA 发起交易调用合约。

- 从链上角度看，依然是“某个地址发起了一笔交易”，合约只是被动地在交易执行过程中跑自己的逻辑。

**2.3 UserOperation + Bundler 的“捆绑操作”**

做一个最新的补充：

捆绑操作模型更像你写好很多办事单子（UserOperations），把它们交给一个代办服务（Bundler），代办服务帮你拿到银行审批，通过
EntryPoint 办理这些操作。

截至 2025 年：

- ERC-4337 形成了**独立的“替代 mempool”（alt mempool）**，UserOperation
  在这里被收集，再由 Bundler 打包为普通 L1 交易。

- 越来越多钱包（如 Safe + 4337 模块、Rhinestone 等）直接提供 AA
  钱包体验，但它们依然依赖某个 Bundler/节点在底层用 EOA 把操作送上链。

**2.4 账户抽象的现状：ERC-4337 + 即将到来的 EIP-7702**

近期更新：

【从 ERC-4337 到 EIP-7702】

- **ERC-4337**：已经在主网运行两年多，被视为“**不改共识层实现账户抽象的第一阶段**”，生态里已经有几十个钱包和项目基于它构建智能账户系统。

- **EIP-7702 + Pectra 升级**：被设计为在协议层引入一种新交易类型，让 EOA
  在单笔交易期间可以**临时挂载一段合约代码**，或者持续委托给一个合约地址，从而“像智能钱包一样”执行批量操作、代付
  gas 等高级逻辑，而不用迁移到新地址。

但要特别强调的一点：

> 即便有 ERC-4337 和即将到来的 EIP-7702，从共识 /
> 协议层看，“只有具备签名能力的账户（EOA 及其扩展形式）才能发起 L1
> 交易”这一根本规则依然没变；合约账户本身仍然不能凭空在链上创建新的顶层交易。

**给出一句话（可以直接背诵）**

小结：

> 今天为止：链上的每一笔交易，起点仍然是某个 EOA 的签名；
> 合约账户再“聪明”，也只是被调用时执行，而不是自己起头发交易。
> 账户抽象和 EIP-7702
> 做的事，是让“谁来签、怎么付费、怎么组合操作”更灵活，而不是改变这一条物理定律。

# 合约账户能存储余额和状态吗？

以太坊中的每个账户（无论是 EOA 还是合约账户）在“世界状态”（world
state）里，都被建模为一个**四元组**：

0

四个字段的**官方定义**：

- **nonce**

  - 对 EOA：记录该地址已经发送过多少笔交易；

  - 对 **合约账户**：记录该合约地址“创建了多少个合约”（通过
    <span class="mark">CREATE</span> /
    <span class="mark">CREATE2</span>）。

- **balance**

  - 账户持有的 ETH 数量（单位为 wei，1 ETH = 10¹⁸ wei）。

  - **EOA 和合约账户都可以持有余额，并且都能收款 /
    付款（只不过合约“付款”的逻辑由代码控制）。**

- **storageRoot**

  - 这是一个 Merkle-Patricia Trie（或将来 Verkle
    Trie）**根哈希**，指向该账户的“存储树”（account storage trie）。

  - **只有合约账户才真正使用这个字段**：用来保存合约的状态变量（<span class="mark">mapping</span>、<span class="mark">uint</span>、<span class="mark">address</span>
    等）的键值对；

  - 对 EOA，规范上这个字段也存在，但值是“空存储根”（默认值）。

- **codeHash**

  - 合约账户： EVM 字节码的哈希 —— 用来标识和校验合约代码；

  - EOA：没有代码，**规范上 codeHash
    是空字符串的哈希**（相当于“没有代码”的占位标记）。

> 也就是说：从协议内部看，EOA 和合约账户在结构上是同一种账户对象，只是对
> EOA 来说 codeHash / storageRoot 这两个字段是“空的 /
> 没意义”；你用“只有合约账户才有存储、才真正使用
> storageRoot”来讲是完全可以的，只要在脚注提醒一下“规范里字段也挂在 EOA
> 上，但不真正使用”就够了。

## 存储余额与状态

**1.1 余额（balance）**

- 合约账户同样拥有 ETH 余额字段，可以像 EOA 一样接收 ETH：

  - 收款：直接向合约地址转账；

  - 付款 / 用钱：在合约代码中通过 <span class="mark">transfer</span> /
    <span class="mark">call{value: ...}</span> /
    <span class="mark">selfdestruct</span> 等方式转出。

- 文档和教程也都明确写着：**合约账户可以像 EOA 一样持有 ETH 和代币**。

唯一的区别是：

- EOA 用“私钥签名 + 交易”来花钱；

- 合约账户靠“代码逻辑”来决定何时、向谁、在什么条件下花钱。

**1.2 存储变量（state）**

- 合约账户拥有独立的 **storage trie**，保存所有在合约中定义的状态变量：

  - 例如 <span class="mark">mapping(address =\> uint256)
    balances;</span>、<span class="mark">uint256 totalSupply;</span>
    等，都会映射到这棵存储树中的一个或多个
    <span class="mark">slot</span>；

  - 这棵树的根哈希就是账户状态中的 <span class="mark">storageRoot</span>
    字段。

- EOA 没有代码，也不能修改自己的 storage，因此它的
  <span class="mark">storageRoot</span> 在实现里是固定的空值。

**对比表：**

| **属 性** | **EOA** | **合约账户** |
|:---------:|:---------------------------|:--------------------------------|
| 私钥 | 有私钥，可签名交易 | 无私钥，不能主动签名 |
| balance | 有余额字段 | 同样有余额字段（可以像 EOA 一样持有 ETH / 代币） |
| codeHash | **逻辑上“无代码”；规范中存的是空代码哈希** | 有字节码哈希，用于合约执行与识别 |
| storageRoot | **逻辑上“无存储”；规范中是空存储根** | 有 trie 根，用于存储合约状态 |

> 从“写合约 / 用合约”的角度——
>
> **“只有合约账户才有状态存储、才真正使用 storageRoot / codeHash”**
> ——对读者是很友好的抽象；只是从协议实现看，这两个字段在 EOA
> 上也“占了一个坑”，但不承载实际业务含义。

**1.3 补充解释 codeHash**

> 在以太坊中，codeHash 是合约账户（Contract
> Account）状态的一部分，表示该合约账户的字节码（bytecode）的哈希值。
>
> 对于 EOA，由于没有合约代码，codeHash 通常为空字符串的哈希…

这和现在的规范以及实现完全一致，再加两点“面向开发”的 info：

**①为什么要存哈希而不是直接把 code 塞进账户对象？**

- account 四元组会被编码进状态 trie，如果每次余额或 nonce 变化都重新 RLP
  整段 code，会非常浪费；

- 代码实际单独存储，**账户里只存 codeHash 作为“指针 + 防篡改承诺”**。

**②在工具里怎么看到 code？**

- 通过 **<span class="mark">eth_getCode(address)</span>** 可以根据
  codeHash 拿回真实字节码；

- 区块浏览器会基于 codeHash 做合约识别与“已验证源码”匹配。

**补充一点 2024–2025 的“未来视角”：Verkle / Stateless
不会改变“账户能否存余额和状态”这件事**

最近几年大家讨论很多的 Verkle Trees、Stateless
Clients、本地状态压缩等研究，主要是想解决 **“节点存太多状态太重”**
的问题：

- 黄皮书 + 最新研究仍然以“账号状态四元组（nonce, balance, storageRoot,
  codeHash）”作为逻辑抽象；

- Verkle / Binary Merkle / VOPS 等提案，改变的是 **state
  在底层树结构中的存储方式和证明方式**，而不是“合约能不能存余额和状态”；

> 换句话说：
>
> **就算以后底层从 Merkle-Patricia Trie 换成 Verkle
> 或统一二叉树，对开发者而言： “合约账户能收 ETH、能持久化状态变量”
> 这件事实不会改变，只是 <span class="mark">storageRoot</span>
> 的内部含义会变得更“高科技”一点。**

**1.4 类比帮助大家理解：**

来做个收尾：

把“合约账户能存余额和状态”比作现实中的一个“银行账户 + 自动柜台”：

- **余额（balance）** 就是这家账户里的钱，EOA 和合约账户都有；

- **storage（state）**
  像这家账户背后的一整柜档案：白名单、黑名单、股东名册、积分、配置表……

- **codeHash + storageRoot** 就像“这家银行柜台的工作手册版本号 +
  档案柜目录编号”，保证你每次查到的都是一致的版本。

合约账户之所以特别，是因为：

**它既有钱（balance），又有“记账本 /
档案柜”（storage），还内置了一套“如何动这些钱、如何改这本账”的自动规则（code）。**

这就是为什么 DeFi 协议、NFT 合约、DAO 国库 都爱用“合约账户”：

既能收钱，又能记账，还能自动执行规则。

# EOA和合约账户如何互相调用？

## 从 EOA 发起调用到合约账户

EOA 用户通过私钥签名发起**外部交易（external
transaction）**，交易中会包含：

- <span class="mark">to</span>：目标合约地址（或 EOA 地址）

- <span class="mark">data</span>：编码后的调用数据（函数选择器 + 参数）

- <span class="mark">value</span>：附带发送的 ETH（可选）

- <span class="mark">gas</span> 与 <span class="mark">gasPrice /
  maxFee</span> 等字段

这笔交易被广播到以太坊网络，进入内存池（mempool），最终被验证者打包进区块并执行。

当交易被执行时：

①EVM 会根据 <span class="mark">to</span> 找到目标合约账户，加载其
<span class="mark">codeHash</span> 对应的字节码；

②用 <span class="mark">data</span> 作为输入执行合约函数逻辑；

③过程中可以修改合约的存储状态（storage）、向其他地址转账
ETH，或触发事件（logs）。

术语对应：

- 从 EOA 发起的“带
  <span class="mark">to</span>/<span class="mark">data</span> 的交易”是
  **交易（transaction）**；

- 在 EVM 执行过程中合约之间互相调用，是 **消息调用（message call /
  internal transaction）**。

## 合约账户之间的调用（合约互调用链路）

在合约执行过程中，当前合约可以通过 EVM 的若干 opcode（在 Solidity
中表现为不同的低级调用）与其他合约账户交互，例如：

- <span class="mark">call</span>：普通调用，对方在自己的存储中执行逻辑，<span class="mark">msg.sender</span>
  变为当前合约；

- <span class="mark">delegatecall</span>：**在当前合约的存储上下文中执行对方代码**——存储读写仍落在发起方（调用者）合约上，<span class="mark">msg.sender</span>/<span class="mark">msg.value</span>
  保持外层值，常用于代理 / 升级模式；

- <span class="mark">staticcall</span>：只读调用，不允许修改状态，只能
  <span class="mark">view/pure</span>。

这些调用：

- 在链上表现为**内部交易（internal transactions/message
  calls）**，不会额外生成一条新的顶层 transaction 记录；

- **仍然消耗 gas**，但消耗的是当前这笔外部交易预付的
  gas；合约本身不能“再多发一笔交易来买 gas”，只能在既有 gas
  限额里完成所有子调用；

- Solidity 里通常可以拿到调用结果：<span class="mark">(bool success,
  bytes memory ret) = other.call(...);</span>，根据返回值决定后续逻辑。

“链上内部消息（内部交易）”在学术和工具文献里是这样定义的：

> 外部交易由 EOA 发起，合约间调用被称为 internal transactions / message
> calls，由 EVM 执行引擎在同一条交易上下文中完成。

## 合约账户无法主动发起 EOA 级交易

这一点截至 2025 年依然是**铁律**：

- 合约账户没有私钥，无法对“新交易”进行签名，因此不能“凭空”构造一笔新的
  **外部交易**；

- 合约账户可以在执行过程中通过 <span class="mark">call{value:
  ...}</span> 等方式给 EOA
  或其他合约地址转账、调用对方函数，但这都是**当前交易内部的 EVM
  步骤**，而不是额外生成一条新的顶层 transaction。

> 换句话说：一条链上交易的“起点”永远是某个具备签名能力的账户（传统 EOA
> 或经过 AA 扩展的 EOA），合约只是这条执行路径里的“中间站”。

## 补充解释一些新东西：AA 钱包、ERC-4337 与 EIP-7702

账户抽象、捆绑操作，在“谁起头发交易”，只是让调用链更绕了一层，现在额外补充两个结论：

**4.1 ERC-4337（EntryPoint + Bundler）**

- 用户（通常是智能合约钱包）构造一个
  <span class="mark">UserOperation</span>，交给 Bundler；

- Bundler 用自己的 EOA 发起一笔普通交易，调用 EntryPoint 合约 的
  <span class="mark">handleOps</span>；

- EntryPoint 再在内部依次 <span class="mark">call</span>
  各个智能钱包和目标合约

从底层看：**真正写进区块的，仍然是一笔由 Bundler 的 EOA
发起的交易**，钱包/合约之间的交互全是内部调用。

**4.2 EIP-7702（Pectra 升级已在 2025 启用）**

- 为 EOA 引入新的 **Type-4 “set code” 交易类型**，允许 EOA
  在一个交易生命周期内临时挂载一段合约代码，拥有“智能钱包式”的批量执行、Gas
  赞助等能力；

- 但这依然是“EOA
  发出一笔交易，然后在执行期间委托某段代码处理逻辑”，并没改变“合约不能凭空发起顶层交易”的基本规则。

**  **

**对照表：**

| **发起方** | **调用对象** | **方式** | **描述** |
|:---------:|:----------|:-------------:|:------------------------------------|
| EOA | 合约账户 | **外部交易（transaction）** | 使用私钥签名发起，广播到网络，被打包后触发合约执行，是整个调用链的起点。 |
| 合约账户 | 合约账户 | <span class="mark">call</span> / <span class="mark">delegatecall</span> / <span class="mark">staticcall</span> 等 | 在同一笔交易执行上下文中的**内部消息调用**，消耗当前交易的 gas，不会生成新的顶层交易记录。 |
| 合约账户 | EOA | 不能主动“发交易” | 可以在执行过程中通过 <span class="mark">call{value: ...}</span> 给 EOA 地址转 ETH（内部调用），但不能像 EOA 那样签名并广播一条独立交易。 |
| EOA / Bundler | 钱包合约+ 目标合约 | 交易 + 多层内部 call | 在 ERC-4337 / EIP-7702 模式下，由 Bundler 或挂载代码后的 EOA 发起一笔交易，再由 EntryPoint / 钱包合约在内部批量调用多个合约，本质仍是一条 EOA 起头的交易。 |

一句话（可以直接背诵）

> 外部交易永远是 EOA → 合约（或 EOA），之后在同一笔交易里才会出现合约 →
> 合约 / 合约 → EOA 的内部调用链。

# 常见的钱包（MetaMask等）如何管理EOA？

## 私钥与助记词

当你初次使用 MetaMask 创建钱包时，它会在本地生成一个 **12 个英文单词**
的 Secret Recovery Phrase（SRP，助记词），遵循 BIP-39
标准，从这个种子可以派生出多个私钥与 EOA 地址。

- **SRP / 私钥全部保存在本地设备**：

MetaMask 会用你设置的钱包密码对 SRP 与私钥进行加密，存放在浏览器扩展 /
手机本地存储中，不会上传到 MetaMask 服务器。丢了 SRP
官方也无法帮你找回。

- **拿到 SRP = 控制所有该钱包下的账户**：

SRP 是“主钥匙”，所有基于它派生出来的 EOA 都可以被恢复，所以任何获得你
SRP 的人都可以完全控制你的资金与操作。

> 官方现在明确写在帮助中心里：MetaMask 不会保存你的
> SRP，任何“客服”向你要助记词，都是诈骗。

## EOA 的生成与切换

钱包基于 SRP，按照 BIP-32/BIP-44 的分层确定性规则（HD
wallet），在本地连续派生出一串 EOA 地址（比如常见的
<span class="mark">m/44'/60'/0'/0/0</span>、<span class="mark">0/1…</span>
这些路径）。

- 在界面里，你点击“创建账户”，其实就是让钱包**用同一个 SRP
  派生下一个地址**，而不是再生成一套新的种子。

- 你也可以在 MetaMask 中**导入单独私钥**或另一套助记词，从而把其他钱包的
  EOA 一并管理。

- 同一个 EOA 地址可以同时连接多个 EVM
  兼容链（以太坊主网、OP、Arbitrum、BSC
  等），只是每条链上余额与状态相互独立。

EOA 的“选择 / 切换”本质上就是：告诉 dApp“当前用哪个派生地址签名交易”。

## 交易签名流程（MetaMask 如何用 EOA 发交易）

当你在 dApp 里点“Swap”“Mint”“Stake”等按钮时，大致会经历这些步骤：

①dApp 通过 <span class="mark">window.ethereum</span> / EIP-1193
请求你的钱包发起交易；

②MetaMask 弹窗展示：

- 目标地址 <span class="mark">to</span>

- 调用数据 <span class="mark">data</span>（对应合约函数 + 参数）

- 发送的 ETH 数量 <span class="mark">value</span>

- 预计 gas 费用等

③你确认后，钱包在**本地**用当前 EOA 的私钥对这笔交易做 ECDSA 签名；

④钱包再通过你配置的 RPC 节点（官方默认或自定义，如
Infura、自建节点等）把签名后的交易广播到链上。

关键点：

- 节点只看到“已经签名好的交易”和你的地址，看不到你的私钥；

- 是否广播、是否签名，完全由你本地的钱包控制。

## 支持智能账户拓展（Account Abstraction）

“智能账户（Smart Account）”，在实际实现上主要是基于 **ERC-4337
账户抽象** 标准，再配合钱包自己的 UI 与后端服务。

**4.1 MetaMask Smart Accounts（基于 ERC-4337）**

截至 2025 年，MetaMask 在桌面扩展 v12.17.0+ 已经正式支持所谓的 **Smart
Account / Account Abstraction**：

- 底层依托 ERC-4337 引入的 EntryPoint、UserOperation、Bundler、Paymaster
  等组件，让“合约账户”可以作为用户主账户；

- 提供 **批量操作**、**Gas 赞助 / 使用代币付
  gas**、**更灵活的恢复策略（如社交恢复、多签逻辑）** 等高级功能；

- 用户可以在 MetaMask
  界面里在“普通账户（EOA）”与“智能账户（合约钱包）”之间切换；但底层仍然是你掌握
  SRP / 私钥，MetaMask 官方不会托管密钥。

ERC-4337 生态在 2024–2025
年发展非常快，很多项目和钱包都在用它实现智能账户和 gasless 体验。

「通过 EIP-7702/4337」可以理解为：

- **当前主流钱包（包括 MetaMask）真正落地的是基于 ERC-4337 的 Smart
  Account；**

- **EIP-7702 则是在协议层为这种“智能账户行为”补了一块更底层的基石。**

**4.2 EIP-7702：协议层让 EOA “临时变聪明”**

现状与定位：

- 状态：EIP-7702 已随 2025 年的 Pectra 升级在以太坊主网激活（包含在
  Pectra 硬分叉中），并在 Sepolia 等测试网可用。

- **它引入新的 0x04 交易类型（SetCode / Authorization 类型）**，允许 EOA
  在一笔交易的执行生命周期内，临时把自己“挂接”到某个合约代码上，让这笔交易期间对该地址的操作都委托给那段合约代码执行。

- 设计目标是：

  - 让 EOA 也能拥有类似智能钱包的能力（批量操作、session
    key、社交恢复、更多签名机制…）；

  - 与现有 ERC-4337 AA
    生态兼容，而不是互斥。[Alchemy+1](https://www.alchemy.com/blog/eip-7702-ethereum-pectra-hardfork?utm_source=chatgpt.com)

概括：

> EIP-7702 把“EOA
> 能不能执行合约逻辑”这件事，放进了协议层，用一种可授权、可撤销、带
> nonce 防重放的新交易类型来做；钱包（包括
> MetaMask）可以在此基础上继续构建更上层的智能账户体验。

风险点（授权给恶意合约、存储布局冲突、nonce
管理复杂度、用户误操作等），在目前社区讨论中依然被视作需要注意的安全重点，尤其是开发者在实现时必须充分审计授权合约与授权流程。

## 备份与安全防诈骗（与现在官方建议对齐）

备份方式 & 钓鱼手法很实用，额外加一句“和官方安全指引对齐”的补充：

- MetaMask 官方现在在安全文档和 2025 年的安全报告中，反复强调几件事：

  - **永远不要把 SRP /
    私钥输入到网页表单、发给“客服”、截图发给任何人；**

  - 官方支持不会以任何理由向你索要助记词；

  - 备份尽量使用离线、物理介质（纸张 / 金属板 /
    保险箱等），避免明文存云盘或聊天软件；

  - 警惕钓鱼站、假钱包扩展与伪造签名弹窗。

各种钓鱼场景（假客服、假官网、恶意
App、剪贴板劫持等），这些不是理论，已经在真实攻击中多次出现”即可。

**小结**

- **MetaMask 这类钱包管理 EOA 的核心依然是：本地生成 / 加密保存 SRP →
  本地派生私钥 / 地址 → 本地签名 → 通过 RPC 广播。**

- **账户抽象（ERC-4337）+ EIP-7702 只是把“这个 EOA
  能做什么”变得更灵活，而不是改变“私钥归谁所有”这件底层事实。**

- 对用户来说，重点没变：

> 记好助记词、管好私钥、看清每一次签名弹窗，
>
> 其余的“智能账户”“批量交易”“gas 赞助”“7702
> 高速通道”，都只是你之上的“外挂”和“外骨骼”。

# ERC‑20或ERC‑721代币与合约账户有什么关系？

## 代币就是智能合约存储的“记账系统”

ERC-20
合约（用于同质代币）内部会维护类似下面这些状态变量，用来记录余额和授权额度：

也就是说，当你“拥有” ERC-20 代币时，**真正的资产记录是这份合约的 storage
中那几行映射数据**，而不是“某个地址里多了一袋硬币”。不同实现的变量名可能略有差异（<span class="mark">\_balances</span>、<span class="mark">balances</span>
等），但逻辑都是：**合约用映射来记账**。

ERC-721 合约（用于 NFT）则保存的是**每个唯一
<span class="mark">tokenId</span>
的持有者地址**，以及余额映射和可选的枚举 / 元数据等结构，例如：

加上一些扩展（如
<span class="mark">tokenURI</span>、Enumerable），就能把“这是谁的第几号
NFT、对应什么元数据”都记录在合约存储中。

> 总结一下：ERC-20 / ERC-721 代币本质上都是某个合约账户里的“记账表 +
> 规则”。

## 代币操作就变成了合约调用

如果你想转移代币，并不是“从地址 A 打一笔‘代币转账交易’给地址 B”，而是：

①你的 EOA 向**代币合约地址**发起一笔交易；

②交易的 <span class="mark">data</span> 字段里编码了要调用的函数，例如：

- ERC-20：<span class="mark">transfer(to,
  amount)</span>、<span class="mark">approve(spender,
  amount)</span>、<span class="mark">transferFrom(from, to,
  amount)</span>；

- ERC-721：<span class="mark">safeTransferFrom(from, to,
  tokenId)</span>、<span class="mark">approve(to, tokenId)</span> 等。

③代币合约在 EVM 中执行：

- 检查调用者权限、余额是否足够；

- 更新 <span class="mark">\_balances</span> /
  <span class="mark">\_owners</span> /
  <span class="mark">\_allowances</span> 等存储；

- 发出
  <span class="mark">Transfer</span>、<span class="mark">Approval</span>
  等事件；

- 可能还会回调其他合约（比如 <span class="mark">onERC721Received</span>
  钩子，在 2025 年的安全审计文献里甚至被点名是 NFT
  领域重入攻击的重要入口）。

所以：**“转代币” 本质上是 “调用代币合约的一段代码 + 改一行存储”**。

## 合约账户是逻辑执行与数据存储中心

一个 ERC-20 或 ERC-721 合约账户，本质上就是一个“代币系统的逻辑 +
数据”打包体：

- 它有自己的地址（例如 <span class="mark">0xTokenContract...</span>）；

- 它的 <span class="mark">codeHash</span>
  标识这段代币逻辑（转账、授权、mint、burn 等）；

- 它的 <span class="mark">storageRoot</span> 对应完整的存储树：

  - 谁有多少余额；

  - 谁被授权可以代为花费多少（ERC-20 allowance）；

  - 每个 <span class="mark">tokenId</span>
    属于谁、元数据在哪里（ERC-721）。

在 2024–2025
年，大多数主流代币合约都会在这个基础上叠加更多“合约逻辑”：比如可升级代理、访问控制、铸造
/ 销毁权限、手续费机制等，但**本质仍然是“一个合约账户 + 一棵状态树”**。

## 用户持有代币，是合约里那份“账”

EOA 地址本身**并不存放 ERC-20 / ERC-721
代币对象**，它只在代币合约的映射里作为一行 key 出现。

- 当钱包（MetaMask、Rainbow、钱包 App 等）展示你的代币余额时，本质是：

  - 先知道“这个代币的合约地址”；

  - 调用代币合约的 <span class="mark">balanceOf(yourAddress)</span> /
    <span class="mark">ownerOf(tokenId)</span> 等接口；

  - 把返回的数字（或 NFT 列表）渲染在界面上。

- 区块浏览器（如 Etherscan）也是同理：只要知道“代币合约地址 +
  用户地址”，就能实时从合约 storage 中读出来。

所以更精确地说：

> 你“拥有”某个 ERC-20 / ERC-721
> 代币，并不是因为你的地址里有一包代币，而是：**在那个代币合约的 storage
> 里，有一条记录写着：这个地址的余额是多少 / 这个 tokenId 的 owner
> 是谁。**

# 合约账户一旦部署还能被修改或删除吗？

整体结论：**合约代码默认仍然是“不可修改的”，但“删除”这件事在 Dencun
升级（2024-03-13）之后已经基本被废掉，只在极少数同交易场景下还算真正删除。日常开发应视为：合约一旦部署，就几乎不能改、也不能删，只能通过代理等模式“曲线升级”。**

## 代码不可更改

> 代码不可更改：合约部署后，字节码存储在指定地址，默认为不可变。

而且在 Dencun/EIP-6780 生效后更“硬核”：

- 合约账户在状态树里包含 <span class="mark">codeHash</span>
  字段，用来引用部署好的 EVM
  字节码；一旦写入，这段代码就不会被就地修改。

- 升级协议时，核心开发者专门引入了新的规则，让任何依赖“修改 /
  替换代码”的用法都变得不可靠或直接失效，目的是为后续 Verkle
  tree、无状态客户端铺路。

**不要指望“换代码”，只能换合约地址或用代理模式**。

## SELFDESTRUCT：现在基本“不再真的删合约”了

> 可选的 SELFDESTRUCT：如果合约中实现了 SELFDESTRUCT（或
> DELEGATECALL+SELFDESTRUCT
> 等组合），它可以在执行时销毁自身代码和状态，也可能将 ETH
> 转移到指定地址。

这段在**历史上**是对的，但在 2024 年 Dencun
升级以后，已经不再准确，需要加上“新语义”的注脚：

- EIP-6049 先把 <span class="mark">SELFDESTRUCT</span>
  标记为**待废弃（deprecated）**，提示未来语义会改变；Solidity
  文档也明确不推荐在新合约中继续使用。

- EIP-6780（随 Dencun 上线）真正改变了语义：

  - **只有在“合约创建的同一笔交易里调用 SELFDESTRUCT”**
    才会像以前一样，彻底删除该合约的代码和存储；

  - **如果合约是早在过去就部署好的，然后在后续交易中调用
    <span class="mark">SELFDESTRUCT</span>，现在只会转走余额，不再删除代码和
    nonce**——合约的代码实际上还留在链上，只是状态被特殊处理。

学术和社区文章已经明确指出：

> 在 EIP-6780 后，SELFDESTRUCT
> 不再能用来“清空地址并为重新部署腾位置”，除非在同一 transaction
> 内创建并销毁，这对依赖它实现“代码变形 / 重新部署”的模式等于判死刑。

**更新理解：**

- “可以销毁自身代码和状态”这句话，现在需要限定为：**仅在“创建同交易内调用”的极端场景才成立**。

- 在实际业务合约里，**不应该再设计依赖
  <span class="mark">SELFDESTRUCT</span>
  的逻辑**（包括清库、升级、锁仓等），因为行为已变且未来还有被进一步收紧甚至删
  opcode 的可能。

## 地址可重部署：Metamorphic 合约模式几乎被 EIP-6780 “封杀”

> 地址可重部署：自销毁后，通过 CREATE2
> 机制，有可能在相同地址重新部署新合约（metamorphic
> contract），但必须在初始部署时设计并允许这种行为。

这说的是经典的 **Metamorphic Contract Pattern**：

- 利用 <span class="mark">CREATE2</span> 的可预言地址 +
  <span class="mark">SELFDESTRUCT</span> 重置
  nonce，在**旧语义**下，可以在同一地址反复部署不同字节码，实现“同地址不同逻辑”的“合约变形”。

但是在 EIP-6780 之后：

- 一旦合约是在**过去的某笔交易**中部署的，之后的
  <span class="mark">SELFDESTRUCT</span> 不会再真正清掉代码；

- 这意味着：**大多数依赖 <span class="mark">SELFDESTRUCT +
  CREATE2</span> 的 metamor-**

> **phic
> 合约模式已经失效**，不能再假设“自毁后地址干净，可以重新部署全新的代码”。官方
> EIP 明确把这种用法列为“将被破坏且不再安全”的模式之一。

参考历史：

> 地址可重部署（历史上的模式）：
>
> 过去开发者会用 <span class="mark">SELFDESTRUCT + CREATE2</span> 做所谓
> metamorphic
> contracts，在同一地址多次部署不同字节码，实现“同地址升级”。但
> **EIP-6780
> 实施后，这种模式在绝大多数场景下已经失效或被认为不安全**，不应再作为升级方案使用，只能当成历史课题或
> CTF 题目来了解。

## 代理合约模式（Proxy Pattern）：现在几乎是唯一主流升级方案

> 代理合约模式（Proxy
> Pattern）：大多数“可升级合约”采用代理模式——主合约（proxy）永不变，只是可指向不同的实现合约地址，通过
> delegatecall 调用新的逻辑，实现功能升级，同时保留原始地址和状态。

在 <span class="mark">SELFDESTRUCT</span>
被弱化之后，**更成为主流推荐方案**：

- 安全审计公司和社区普遍建议：**如果要做可升级合约，请使用代理架构（如
  Transparent Proxy、UUPS、ERC-2535 Diamond 等），不要再依赖
  <span class="mark">SELFDESTRUCT</span> + CREATE2 这类黑魔法**。

- OpenZeppelin 等主流库已经围绕代理模式形成一整套工具链（合约基类 +
  插件 + 脚本），新项目基本都会走这一套。

一句话（可以直接背诵）：

> 现在的“正确姿势”是：地址不变 → 代理合约；逻辑变更 →
> 换实现合约地址。不要再用 SELFDESTRUCT 做升级。

## 补充一点用户如何与合约账户交互实现功能？

补充：

> 以太坊合约账户交互的核心在于：用户（EOA）通过签名交易或“读”请求，将调用数据发送到合约地址，EVM
> 按合约字节码执行逻辑并更新存储或返回数据。整个过程可在不同层面完成，包括区块浏览器的“写合约”界面、钱包插件（如
> MetaMask）的内置调用、使用前端库（Web3.js/Ethers.js）在网页或脚本中直接调用，以及借助
> Truffle/Hardhat
> 等框架在控制台或脚本中管理合约。无论哪种方式，都需要合约地址与
> ABI（或合约接口），并通过 JSON-RPC 与节点通信。

**2024–2025 的工具生态现状：**

- JS 侧现在更常用 **ethers.js、viem** 等库来发起 JSON-RPC 调用；

- 合约开发测试更多转向 **Hardhat / Foundry**；

- 日常用户大多通过钱包（MetaMask、Rabby 等）签名，前端则只是把 ABI +
  参数编码成 <span class="mark">data</span> 发送给节点。
